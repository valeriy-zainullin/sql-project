Проект по курсу "Базы данных".

1. Защита темы. Тема может быть абсолютно любой, но при этом все данные и функционал над ними должен быть логичен и оправдан в рамках этой темы. Также темы не должны повторяться в рамках одной группы (или 2х групп, которые занимаются вместе). 

    **Тема:** база данных производителя электроники. Он производит моноблоки и мониторы. В будущем может выйти на новые рынки. Собирает отзывы клиентов, клиенты могут редактировать отзывы -- храним все версии. Стоит хранить все версии, ведь какой-то отзыв может послужить причиной для изменений в последующем продукте. Если отзыв поменяют, нужно в документах ссылаться именно на отзыв на момент разработки.
1. Создание концептуальной модели. Концептуальная модель схемы представляет из себя диаграмму, состоящую из значащих таблиц и связей между ними. Нормализация на данном этапе не требуется. Необходимое условие - 5-6 значащих таблиц.
    
    [Диаграмма](modeling/Diagram.png) в нотации "воронья лапка". Для создания спользовался сайт [dbdiagram.io](dbdiagram.io). [Исходники диаграммы](modeling/dbdiagram.txt).
1. Создание логической модели. Подразумевает перевод схемы в одну из нормальных форм (2 или 3, с оправданием выбора), наличие минимум одной таблицы с версионными данными (с оправданием типа версионирования).

    [comment]:<> (collapsible sections доступны, как минимум, в github, gitlab, vscode, jupyter notebook; https://www.emmanuelgautier.com/blog/markdown-collapsible-section)

    <details>
    <summary>Нажмите, чтобы раскрыть. Про нормальные формы (у нас 3-НФ)</summary>


    [Видео по нормальным формам](https://www.youtube.com/watch?v=J-drts33N8g), которое, на мой взгляд, хорошо объясняет.

    [comment]:<> (ссылки на gitlab и github на файлы лучше оставлять с коммитом, а не на ветку, т.к. их могут поменять, номер слайда поменяется или файл пропадет; в gitlab есть кнопка "permalink")

    Еще есть примеры в [лекции](https://gitlab.com/fpmi-atp/db2022-supplementary/global/-/blob/8797380e3e1bbb1af3201d269fdd4f8112c2fc3b/Lectures/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_04_2024.pdf).

    Самая сильная нормальная форма -- 3-НФ. Эта форма нашей схемы. Рассмотрим нормальные формы и каждую нашу таблицу, проверим, что для нее условия выполнены. Заодно скажем, зачем условия нормальных форм нужны в жизни.

    1-НФ. В 1-НФ, если

    * все строки должны быть уникальны,

        С повторами сложнее работать, нужно обновлять несколько строк. Да и если по смыслу хранится одна и та же инфомрация -- в этом нет смысла. Возможно, если это таблица заказов в магазине: клиент, заказ, мы забыли id заказа (номер заказа с открытия нашего магазина). 
    * каждая ячейка должна содержать только одно значение (не список),

        Это усложняет получение данных в коде, который обращается к БД. Нужно разбивать строку по разделителю и тому подобное, кто-то может по ошибке в базу данных вставить не соответствующую формату списка строку. Ведь к бд можно обратится и не из кода, а из командной строки для каких-то задач администрирования, там не будет проверок типа CHECK (или их придется писать, когда можно было бы не писать).
    * каждое значение должно быть неделимо (нельзя разделить на несколько значений).

        Наверно, чтобы поддержать структурность. Опять же, чтобы нельзя было записать некорректные данные. Например, если мы храним ФИО, из командной строки можно записать строку лишь из одной компоненты или двух. А бывают и составные имена, с пробелами и т.п. Может быть сложно. __Хотя в видео в 3-НФ для имени используют лишь один столбец. Наверно, для наглядности, таблица не для продакшена.__

        Таблица __Monitors__.
        * Повторяющиеся строки нельзя вставить, т.к. у нас есть `id` -- primary key, он должен быть уникальным. Еще по смыслу должен быть уникальным `product_id` -- будет сделано в DDL.
        * У нас нигде нет строкового типа данных, потому список вставить не получится.
        * Если проверить каждое поле, разделить его не получится. Наверно, дело в том, что у нас опять нигде нет строкового типа.

        Таблица __Monoblocks__. Работают рассуждения
        для таблицы __Monitors__, даже названия столбцов
        те же подходят :)

        Таблицы __Cpus__, __Gpus__.
        * Повторяющиеся строки нельзя вставить, т.к. у нас есть `id` -- primary key, он должен быть уникальным.
        * У нас нигде нельзя вставить список по смыслу, одна ячейка интерпретируется как одно значение. Но у нас есть строковый тип данных. Производителя можно написать с большой буквы, всеми маленькими, всеми большими. Потому я навершу проверки, что производитель всегда в title case, модель всегда большими буквами, обе ячейки униальны.
        * Если проверить каждое поле, разделить на несколько не получается.


        Таблицы __Products__, __Reviews__. Есть `id` -- primary key, одинаковые строки вставить нельзя. Список нет, т.к. нигде нет строковых типов, ни одно из полей не интерпретируется как список. Разделить поле на несколько не получается.

        Таблицы __ReviewRevs__, __Users__. Аналогично, есть primary key `id`. Cписок нельзя вставить, т.к. каждая ячейка интерпретируется как одно значение. Разделить на несколько не получается. Касательно уникальности (да, есть `id`, но если выбирать не по нему во WHERE, данные все еще могут быть неконсистентными):
        * в случае равенства (review_id, modified_at) выибраем с наибольшим id, т.к. он был записан в таблицу последним (или просто не смотрим на modified_at даже);
        * (first_name, last_name) не делаем уникальынми, т.к. тезки бывают, но email сделаем уникальным, он тоже будет candidate key;

    2-НФ. В 2-НФ, если

    * в 1-НФ (уже есть),
    * все атрибуты (столбцы), не входящие в primary key, должны определяться всеми элементами candidate key.

        Если поле или несколько полей определяются не всеми элементами candidate key, то лучше вынести завсимость с отдельную таблицу, чтобы гонять меньше одинаковых данных по соединению. Еще можно и foreign key сделать..
    
        Таблица __Monitors__. Cаdndiate key два: `id` и `product_id`, в каждом их них нельзя выделить по меньшему подмножеству. Потому и зависеть от подмножества candidate key (меньшего) не получится.

        Аналогично в каждой таблице. Т.е. схема находится в 2-НФ.

    3-НФ. В 3-НФ, если

    * в 2-НФ (уже есть),
    * все атрибуты должны зависеть не от других атрибутов, а от primary key.
        
        Если пара атрибутов, в котором второй определяется первым. Например, отдел и есть номер телефона сотрудника. А мы знаем, что в отделе лишь один телефон. Тогда, чтобы привести в 3-НФ, надо хранить лишь отдел для сотрудника, и хранить отдельную таблицу отдел-телефон. Когда у сотрудника появится свой рабочий телефон, можно будет дополнить таблицу новым столбцом.
    
        Все таблицы посмотрел, поля, не нашел такого, чтобы поле зависело других. Т.е. 3-НФ тоже есть.
    </details>

    <details>
    <summary>Нажмите, чтобы раскрыть. Про версионирование (у нас SCD 2)</summary>

    Посмотреть информацию по типам версионирования можно в [лекции 6](https://gitlab.com/fpmi-atp/db2022-supplementary/global/-/blob/8797380e3e1bbb1af3201d269fdd4f8112c2fc3b/Lectures/Лекция_06_2024.pdf), на странце 30 есть диаграмма.

    У нас SCD2.
    
    Почему ее выбрали? Потому что самый стандартный вариантj, сразу пришло в голову.
    
    Нам нужно бы хранить все версии, чтобы при разработке ссылаться на версию из прошлого, отзыв может поменяться со временем. И уж точно надо хранить не как отдельные атрибуты в той же таблице, т.к. изменения бывают часто. Отдельные атрибуты годятся, если бывают deprecated значения, хотя даже в этом случае можно мигрировать deprecated значения на новые.

    Как мы понимаем, что это SCD2? Не SCD0, поскольку версионирование есть. SCD2, потому что на новую версию создаем строку, а не перезаписываем (SCD1, в ней подразумевается, что на все ревизии комментария есть лишь одна строка), добавляем новый атрибут (SCD3) или добавляем новую таблицу (SCD4).

    </details>

1. Создание физической модели. Подразумевает определение всей атрибутов всех таблиц схемы с указанием типа данных и всех ограничений.
    
    Уже выполнено на пункте 1, вместе с нотацией "воронья лапка". Посмотреть можно в [диаграмме](modeling/Diagram.png).

1. Реализация схемы посредством DDL-скриптов.

    Реализовано в [scripts/1-create-tables.sql](scripts/1-create-tables.sql)
1. Заполнение схемы данными, с помощью DML-скриптов или прочтения CSV. Требования - не менее 15 строк в каждую значащую таблицу. Не менее 30 строк в каждую таблицу-связку (таблицу, созданную при нормализации схемы, и содержащую ссылки на несколько других, обычно значимых, таблиц). Не менее 30 строк в каждую таблицу, хранящую версионные данные.
1. Написание 10 осмысленных (содержащих WHERE, GROUP BY, HAVING, ORDER BY, JOIN, подзапросы, оконные функции) запросов к схеме, со смысловым описанием желаемого вывода

